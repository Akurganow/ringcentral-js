var define = typeof define === 'function' && define.amd ? define : function (factory) {
    factory(require, exports, module);
};
define(function (require, exports, module) {
    var __extends = this.__extends || function (d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        __.prototype = b.prototype;
        d.prototype = new __();
    };
    var helper = require('../core/Helper');
    var list = require('../core/List');
    var presence = require('./Presence');
    var contact = require('./Contact');
    var Call = function (_super) {
        __extends(Call, _super);
        function Call(context) {
            _super.call(this, context);
            this.list = list.$get(context);
            this.contact = contact.$get(context);
            this.presence = presence.$get(context);
        }
        Call.prototype.createUrl = function (options, id) {
            options = options || {};
            if (!('personal' in options) && !('extensionId' in options))
                options.personal = true;
            return '/account/~/' + (options.personal || options.extensionId ? 'extension/' + (options.extensionId || '~') + '/' : '') + (options.active ? 'active-calls' : 'call-log') + (id ? '/' + id : '');
        };
        Call.prototype.getSessionId = function (call) {
            return call && call.sessionId;
        };
        Call.prototype.isInProgress = function (call) {
            return call && call.result == 'In Progress';
        };
        Call.prototype.isAlive = function (call) {
            return call && call.availability == 'Alive';
        };
        Call.prototype.isInbound = function (call) {
            return call && call.direction == 'Inbound';
        };
        Call.prototype.isOutbound = function (call) {
            return !this.isInbound(call);
        };
        Call.prototype.isMissed = function (call) {
            return call && call.result == 'Missed';
        };
        Call.prototype.isFindMe = function (call) {
            return call && call.action == 'FindMe';
        };
        Call.prototype.getCallerInfo = function (call) {
            return this.isInbound(call) ? call.from : call.to;
        };
        Call.prototype.getAllCallerInfos = function (call) {
            return [this.getCallerInfo(call)].concat(this.isInbound(call) ? call.to : call.from);
        };
        Call.prototype.formatDuration = function (call) {
            function addZero(v) {
                return v < 10 ? '0' + v : v;
            }
            var duration = parseInt(call.duration), hours = Math.floor(duration / (60 * 60)), mins = Math.floor(duration % (60 * 60) / 60), secs = Math.floor(duration % 60);
            return (hours ? hours + ':' : '') + addZero(mins) + ':' + addZero(secs);
        };
        Call.prototype.filter = function (options) {
            options = this.utils.extend({
                alive: true,
                direction: '',
                type: ''
            }, options);
            return this.list.filter([
                //{condition: options.alive, filterFn: this.isAlive},
                {
                    filterBy: 'direction',
                    condition: options.direction
                },
                {
                    filterBy: 'type',
                    condition: options.type
                }
            ]);
        };
        Call.prototype.comparator = function (options) {
            return this.list.comparator(this.utils.extend({ sortBy: 'startTime' }, options));
        };
        /**
     * Injects contact field with appropriate {IContact} data structure into all callerInfos found in
     * all calls Warning, this function may be performance-consuming, reduce the amount of items passed to contacts
     * and calls
     */
        Call.prototype.attachContacts = function (contacts, calls, options) {
            var _this = this;
            // Flatten all caller infos from all messages
            var callerInfos = calls.reduce(function (callerInfos, call) {
                return callerInfos.concat(_this.getAllCallerInfos(call));
            }, []);
            this.contact.attachToCallerInfos(callerInfos, contacts, options);
        };
        /**
     * Check whether pair of calls are two legs of RingOut
     */
        Call.prototype.checkMergeability = function (outboundRingOutCall, inboundCall, options) {
            var getTime = function (dateString) {
                return new Date(dateString).getTime();
            };
            return (!options.strict || outboundRingOutCall.action && outboundRingOutCall.action.toLowerCase().indexOf('ringout') != -1) && // Check directions
            outboundRingOutCall.direction == 'Outbound' && inboundCall.direction == 'Inbound' && (!inboundCall.startTime && !outboundRingOutCall.startTime || Math.abs(getTime(inboundCall.startTime) - getTime(outboundRingOutCall.startTime)) < (options.maxStartTimeDiscrepancy || 5000)) && // Check that numbers match
            inboundCall.from.phoneNumber == outboundRingOutCall.to.phoneNumber && (inboundCall.to.phoneNumber == outboundRingOutCall.from.phoneNumber || inboundCall.to.name == outboundRingOutCall.from.name)    //TODO Maybe name check is not required
;
        };
        Call.prototype.combineCalls = function (outboundRingOutCall, inboundCall, options) {
            options = options || {};
            var result = [];
            outboundRingOutCall.hasSubsequent = true;
            if (options.merge) {
                outboundRingOutCall.duration = outboundRingOutCall.duration > inboundCall.duration ? outboundRingOutCall.duration : inboundCall.duration;
                // TODO Usually information from inbound call is more accurate for unknown reason
                outboundRingOutCall.from = inboundCall.to;
                outboundRingOutCall.to = inboundCall.from;
                // Push only one "merged" outbound call
                result.push(outboundRingOutCall);
            } else {
                // Mark next call as subsequent
                inboundCall.subsequent = true;
                inboundCall.startTime = outboundRingOutCall.startTime;
                // Needed for sort
                // Push both calls, first outbound then inbound
                result.push(outboundRingOutCall);
                result.push(inboundCall);
            }
            return result;
        };
        /**
     * (!) Experimental (!)
     *
     * Calls in Recent Calls (Call Log) or Active Calls arrays can be combined if they are, for example, two legs of
     * one RingOut. The logic that stands behind this process is simple:
     *
     * - Calls must have opposite directions
     * - Must have been started within a certain limited time frame
     * - Must have same phone numbers in their Caller Info sections (from/to)
     *
     * ```js
     * var processedCalls = Call.processCalls(callsArray, {strict: false, merge: true});
     * ```
     *
     * Flags:
     *
     * - if `strict` is `true` then only calls with RingOut in `action` property will be affected
     * - `merge` &mdash; controls whether to merge calls (reducing the length of array) or give them `subsequent`
     *     and `hasSubsequent` properties
     */
        Call.prototype.processCalls = function (calls, options) {
            var processedCalls = [], callsToMerge = [], self = this;
            // Iterate through calls
            calls.forEach(function (call) {
                var merged = false;
                call.subsequent = false;
                call.hasSubsequent = false;
                // Second cycle to find other leg
                // It is assumed that call is the outbound, secondCall is inbound
                calls.some(function (secondCall) {
                    if (call === secondCall)
                        return false;
                    if (self.checkMergeability(call, secondCall, options)) {
                        // Push to result array merged call
                        processedCalls = processedCalls.concat(self.combineCalls(call, secondCall, options));
                        // Push to array calls that are merged
                        callsToMerge.push(call);
                        callsToMerge.push(secondCall);
                        merged = true;
                    }
                    return merged;
                });
            });
            // After all calls are merged, add non-merged calls
            calls.forEach(function (call) {
                if (callsToMerge.indexOf(call) == -1)
                    processedCalls.push(call);
            });
            return processedCalls;
        };
        /**
     * Converts Presence's ActiveCall array into regular Calls array
     */
        Call.prototype.parsePresenceCalls = function (activeCalls) {
            var _this = this;
            return activeCalls.map(function (activeCall) {
                return {
                    id: activeCall.id,
                    uri: '',
                    sessionId: activeCall.sessionId,
                    from: { phoneNumber: activeCall.from },
                    to: { phoneNumber: activeCall.to },
                    direction: activeCall.direction,
                    startTime: '',
                    duration: 0,
                    type: '',
                    action: '',
                    result: _this.presence.isCallInProgress(activeCall) ? 'In Progress' : activeCall.telephonyStatus,
                    telephonyStatus: activeCall.telephonyStatus
                };
            });
        };
        Call.prototype.getSignature = function (call) {
            var cleanup = function (phoneNumber) {
                return (phoneNumber || '').toString().replace(/[^0-9]/gi, '');
            };
            return call.direction + '|' + (call.from && cleanup(call.from.phoneNumber)) + '|' + (call.to && cleanup(call.to.phoneNumber));
        };
        Call.prototype.mergePresenceCalls = function (presenceCalls, presence) {
            var currentDate = new Date(), activeCalls = this.parsePresenceCalls(presence && presence.activeCalls || []).map(function (call) {
                    // delete property to make sure it is skipped during merge
                    delete call.startTime;
                    return call;
                });
            presenceCalls = this.merge(presenceCalls || [], activeCalls, this.getSessionId, true);
            presenceCalls.forEach(function (call) {
                if (!call.startTime)
                    call.startTime = currentDate.toISOString();
            });
            return presenceCalls;
        };
        Call.prototype.mergeAll = function (presenceCalls, calls, activeCalls) {
            // First, merge calls into presence calls
            var presenceAndCalls = this.merge(presenceCalls || [], calls || [], this.getSessionId, true);
            // Second, merge activeCalls into previous result
            return this.merge(presenceAndCalls, activeCalls || [], this.getSessionId, true);
        };
        return Call;
    }(helper.Helper);
    exports.Call = Call;
    function $get(context) {
        return context.createSingleton('Call', function () {
            return new Call(context);
        });
    }
    exports.$get = $get;
});